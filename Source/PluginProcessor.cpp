/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
JuceMidiInFilterAudioProcessor::JuceMidiInFilterAudioProcessor()
{
}

JuceMidiInFilterAudioProcessor::~JuceMidiInFilterAudioProcessor()
{
}

//==============================================================================
const String JuceMidiInFilterAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int JuceMidiInFilterAudioProcessor::getNumParameters()
{
    return 0;
}

float JuceMidiInFilterAudioProcessor::getParameter (int index)
{
    return 0.0f;
}

void JuceMidiInFilterAudioProcessor::setParameter (int index, float newValue)
{
}

const String JuceMidiInFilterAudioProcessor::getParameterName (int index)
{
    return String();
}

const String JuceMidiInFilterAudioProcessor::getParameterText (int index)
{
    return String();
}

const String JuceMidiInFilterAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String JuceMidiInFilterAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool JuceMidiInFilterAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool JuceMidiInFilterAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool JuceMidiInFilterAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool JuceMidiInFilterAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool JuceMidiInFilterAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double JuceMidiInFilterAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int JuceMidiInFilterAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int JuceMidiInFilterAudioProcessor::getCurrentProgram()
{
    return 0;
}

void JuceMidiInFilterAudioProcessor::setCurrentProgram (int index)
{
}

const String JuceMidiInFilterAudioProcessor::getProgramName (int index)
{
    return String();
}

void JuceMidiInFilterAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void JuceMidiInFilterAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void JuceMidiInFilterAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void JuceMidiInFilterAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    buffer.clear();
    
    MidiBuffer processedMidi;
    int time;
    MidiMessage m;
    
    for (MidiBuffer::Iterator i (midiMessages); i.getNextEvent(m, time);) {
        
        // choose a midi channel which has been chosen
        if (m.getChannel() == midiChannel)
        {
            if (m.isNoteOn())
            {
                uint8 newVel = (uint8) noteOnVelocity;
                m = MidiMessage::noteOn(m.getChannel(), m.getNoteNumber(), newVel);
                DBG("received midi channel on " << m.getChannel()
                << " and current volume is " << newVel);
            }
        }
    }
    midiMessages.swapWith(processedMidi);
}

//==============================================================================
bool JuceMidiInFilterAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* JuceMidiInFilterAudioProcessor::createEditor()
{
    return new MidiInFilterProcessorEditor (*this);
}

//==============================================================================
void JuceMidiInFilterAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    
    // You should use this method to store your parameters in the memory block.
    // Here's an example of how you can use XML to make it easy and more robust:
    
    // Create an outer XML element..
    XmlElement xml ("MIDIFILTERSETTINGS");
    // sliders
    xml.setAttribute ("sliderVolume", noteOnVelocity);
    xml.setAttribute ("midiChannel", midiChannel);
    
}

void JuceMidiInFilterAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    //Load UserParams/Data from file
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));
    
    if (xmlState != nullptr)
    {
        DBG("Call from setStateInformation != nullprt");
        // make sure that it's actually our type of XML object..
        if (xmlState->hasTagName ("MIDIFILTERSETTINGS"))
        {
            DBG("Call from setStateInformation == hasTagName");
            // ok, now pull out our parameters
            
            // sliders
            noteOnVelocity = (double) xmlState->getDoubleAttribute("slider1Val", noteOnVelocity);
            midiChannel = (int) xmlState->getDoubleAttribute("slider2Val", midiChannel);
            
        }
    }

}

//==============================================================================
void JuceMidiInFilterAudioProcessor::setNoteOnVel(float noteOnVel)
{
    noteOnVelocity = noteOnVel;
}


void JuceMidiInFilterAudioProcessor::setMidiChannel(int midiChan)
{
    midiChannel = midiChan;
}

//==============================================================================
float JuceMidiInFilterAudioProcessor::getNoteOnVel()
{
    return noteOnVelocity;
}

int JuceMidiInFilterAudioProcessor::getMidiChannel()
{
    return midiChannel;
}

//==============================================================================

// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new JuceMidiInFilterAudioProcessor();
}
